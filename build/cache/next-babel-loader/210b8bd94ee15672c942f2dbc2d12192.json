{"ast":null,"code":"import jwt from \"jsonwebtoken\";\nimport isEmail from \"validator/lib/isEmail\";\nimport bcrypt from \"bcrypt\";\nimport validateUserData from \"../../utils/validateUserData\";\nimport connectToDatabase from \"../../utils/connectToDatabase\";\nimport { serialize } from \"cookie\";\nexport default (async (req, res) => {\n  if (!req.body) return res.status(204).end();\n  const {\n    error,\n    validatedUserData\n  } = validateUserData(req.body, {\n    minimumLengthForEachField: {\n      username: 5,\n      password: 8\n    },\n    hasEmail: isEmail(JSON.parse(req.body).username)\n  });\n  if (error) return res.status(403).json({\n    ok: false,\n    error\n  });\n  let closeConnection;\n\n  try {\n    const {\n      db,\n      closeConnectionHandler\n    } = await connectToDatabase();\n    closeConnection = closeConnectionHandler;\n    const users = db.collection(\"users\");\n    const foundUser = await users.findOne({\n      $or: [{\n        username: validatedUserData.username\n      }, {\n        email: validatedUserData.email\n      }]\n    });\n    if (!foundUser) res.status(403).json({\n      ok: false,\n      error: \"Numele de utilizator sau e-mailul pe care l-ați introdus nu este corect.\"\n    });else {\n      const passwordsMatch = await bcrypt.compare(validatedUserData.password, foundUser.password);\n      if (!passwordsMatch) res.status(403).json({\n        ok: false,\n        error: \"Parola pe care ați introdus-o nu este corectă.\"\n      });else {\n        const accessToken = jwt.sign({\n          id: foundUser._id,\n          name: foundUser.name,\n          surname: foundUser.surname,\n          username: foundUser.username\n        }, process.env.ACCESS_TOKEN_SECRET, {\n          expiresIn: \"30s\"\n        });\n        const refreshToken = jwt.sign({\n          id: foundUser._id,\n          username: foundUser.username\n        }, process.env.REFRESH_TOKEN_SECRET, {\n          expiresIn: \"7d\"\n        });\n        res.status(200).setHeader(\"Set-Cookie\", [serialize(\"_refreshToken\", refreshToken, {\n          httpOnly: true\n        })], [serialize(\"_accessToken\", accessToken, {\n          httpOnly: true\n        })]).json({\n          ok: true,\n          error: null\n        });\n      }\n    }\n    return closeConnection();\n  } catch (e) {\n    if (closeConnection) closeConnection();\n    console.error(e);\n    return res.status(500).json({\n      ok: false\n    });\n  }\n});","map":{"version":3,"sources":["C:/Users/plesa/Desktop/Proiecte Web/infoplus/pages/api/login.js"],"names":["jwt","isEmail","bcrypt","validateUserData","connectToDatabase","serialize","req","res","body","status","end","error","validatedUserData","minimumLengthForEachField","username","password","hasEmail","JSON","parse","json","ok","closeConnection","db","closeConnectionHandler","users","collection","foundUser","findOne","$or","email","passwordsMatch","compare","accessToken","sign","id","_id","name","surname","process","env","ACCESS_TOKEN_SECRET","expiresIn","refreshToken","REFRESH_TOKEN_SECRET","setHeader","httpOnly","e","console"],"mappings":"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","sourcesContent":["import jwt from \"jsonwebtoken\";\r\nimport isEmail from \"validator/lib/isEmail\";\r\nimport bcrypt from \"bcrypt\";\r\nimport validateUserData from \"../../utils/validateUserData\";\r\nimport connectToDatabase from \"../../utils/connectToDatabase\";\r\nimport { serialize } from \"cookie\";\r\n\r\nexport default async (req, res) => {\r\n    if (!req.body) return res.status(204).end();\r\n    const { error, validatedUserData } = validateUserData(req.body, {\r\n        minimumLengthForEachField: {\r\n            username: 5,\r\n            password: 8,\r\n        },\r\n        hasEmail: isEmail(JSON.parse(req.body).username),\r\n    });\r\n\r\n    if (error) return res.status(403).json({ ok: false, error });\r\n\r\n    let closeConnection;\r\n    try {\r\n        const { db, closeConnectionHandler } = await connectToDatabase();\r\n        closeConnection = closeConnectionHandler;\r\n        const users = db.collection(\"users\");\r\n\r\n        const foundUser = await users.findOne({\r\n            $or: [{ username: validatedUserData.username }, { email: validatedUserData.email }],\r\n        });\r\n\r\n        if (!foundUser)\r\n            res.status(403).json({\r\n                ok: false,\r\n                error: \"Numele de utilizator sau e-mailul pe care l-ați introdus nu este corect.\",\r\n            });\r\n        else {\r\n            const passwordsMatch = await bcrypt.compare(\r\n                validatedUserData.password,\r\n                foundUser.password\r\n            );\r\n            if (!passwordsMatch)\r\n                res.status(403).json({\r\n                    ok: false,\r\n                    error: \"Parola pe care ați introdus-o nu este corectă.\",\r\n                });\r\n            else {\r\n                const accessToken = jwt.sign(\r\n                    {\r\n                        id: foundUser._id,\r\n                        name: foundUser.name,\r\n                        surname: foundUser.surname,\r\n                        username: foundUser.username,\r\n                    },\r\n                    process.env.ACCESS_TOKEN_SECRET,\r\n                    { expiresIn: \"30s\" }\r\n                );\r\n                const refreshToken = jwt.sign(\r\n                    {\r\n                        id: foundUser._id,\r\n                        username: foundUser.username,\r\n                    },\r\n                    process.env.REFRESH_TOKEN_SECRET,\r\n                    { expiresIn: \"7d\" }\r\n                );\r\n\r\n                res.status(200)\r\n                    .setHeader(\r\n                        \"Set-Cookie\",\r\n                        [serialize(\"_refreshToken\", refreshToken, { httpOnly: true })],\r\n                        [serialize(\"_accessToken\", accessToken, { httpOnly: true })]\r\n                    )\r\n                    .json({ ok: true, error: null });\r\n            }\r\n        }\r\n\r\n        return closeConnection();\r\n    } catch (e) {\r\n        if (closeConnection) closeConnection();\r\n\r\n        console.error(e);\r\n        return res.status(500).json({ ok: false });\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"module"}